{"mappings":"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","sources":["src/index.js","src/func/generatePermutations.js"],"sourcesContent":["export * from './func/generatePermutations.js';","export const generatePermutations = (rawInputObject, options = {}) => {\n  const inputObject = preprocessInput(JSON.parse(JSON.stringify(rawInputObject))); // Deep copy and preprocess\n\n\n  // Helper function to apply rules to current combination\n  function applyRules(rules, permutation) {\n    return rules.every((rule) => {\n      if (typeof rule.if === 'function') {\n        // Only apply 'then' conditions if 'if' condition returns true\n        if (rule.if(permutation)) {\n          // Check 'then' conditions for further restrictions\n          return checkThenConditions(rule.then, permutation);\n        } else {\n          // If 'if' condition returns false, this rule does not restrict the permutation\n          return true;\n        }\n      } else if (Array.isArray(rule.if)) {\n        const [field, operator, conditionValue] = rule.if;\n        // Apply 'then' conditions if the operator-based 'if' condition is met\n        return checkRule(field, operator, conditionValue, permutation) ? checkThenConditions(rule.then, permutation) : true;\n      } else {\n        // Throw an error if the rule format is not recognized\n        throw new Error('Invalid rule format: \"if\" should be a function or an array.');\n      }\n    });\n  }\n\n  // Adjusted checkRule function to directly accept the parameters instead of the rule object\n  function checkRule(field, operator, conditionValue, permutation) {\n    function checkCondition(operator, fieldValue, testValue) {\n      switch (operator) {\n        case '==':\n          return fieldValue == testValue;\n        case '!=':\n          return fieldValue != testValue;\n        case '<':\n          return fieldValue < testValue;\n        case '<=':\n          return fieldValue <= testValue;\n        case '>':\n          return fieldValue > testValue;\n        case '>=':\n          return fieldValue >= testValue;\n        default:\n          throw new Error(`Invalid operator \"${operator}\" used in rule definition.`);\n      }\n    }\n\n    let fieldValue = permutation[field];\n    if (Array.isArray(conditionValue)) {\n      // If conditionValue is an array, check if any value in the array meets the condition\n      return conditionValue.some((value) => checkCondition(operator, fieldValue, value));\n    } else {\n      // If conditionValue is not an array, directly check the condition\n      return checkCondition(operator, fieldValue, conditionValue);\n    }\n  }\n\n  // Helper function to check then conditions based on the current permutation\n  function checkThenConditions(thenConditions, permutation) {\n    return Object.entries(thenConditions).every(([field, values]) => {\n      values = Array.isArray(values) ? values : [values];\n      return values.includes(permutation[field]);\n    });\n  }\n\n  // Helper function to apply filters to permutations\n  function applyFilters(permutations, filters) {\n    return filters.reduce((filteredPermutations, filterFunc) => {\n      return filteredPermutations.filter(filterFunc);\n    }, permutations);\n  }\n\n  // Recursive function to generate all combinations\n  function permute(currentCombination = {}, remainingKeys = Object.keys(inputObject)) {\n    // If no remaining keys, apply rules and return the final combination\n    if (remainingKeys.length === 0) {\n      // First, apply rules to see if the current combination is valid\n      if (options.rules && !applyRules(options.rules, currentCombination)) {\n        return []; // If rules are not satisfied, filter out this combination\n      }\n      // If there are filters, apply them as well\n      return [currentCombination]; // Return combination as an array of one\n    }\n\n    let [key, ...nextKeys] = remainingKeys;\n    let results = [];\n\n    // Generate permutations for the remaining keys\n    const newOptions = nextKeys.length > 0 ? { ...inputObject, [key]: inputObject[key] } : inputObject;\n\n    for (let value of inputObject[key]) {\n      let newCombination = { ...currentCombination, [key]: value };\n      results = results.concat(permute(newCombination, nextKeys));\n    }\n\n    return results;\n  }\n\n  // Generate permutations and then apply any filters\n  let allPermutations = permute({}, Object.keys(inputObject));\n  if (options.filters) {\n    allPermutations = applyFilters(allPermutations, options.filters);\n  }\n\n  \n  // Validate input and options\n  if (typeof inputObject !== 'object' || inputObject == null) {\n    throw new TypeError('Input must be an object with array properties.');\n  }\n\n  for (let key in inputObject) {\n    if (!Array.isArray(inputObject[key])) {\n      throw new TypeError(`Value for ${key} must be an array.`);\n    }\n  }\n\n  // Generate and return permutations with rules applied\n  return allPermutations;\n}\n\n\nconst preprocessInput = (inputObject) => {\n  // Function to convert range definition to an array\n  const rangeToArray = (range) => {\n    const { min, max, step } = range;\n    let arr = [];\n    for (let value = min; value <= max; value += step) {\n      arr.push(value);\n    }\n    return arr;\n  };\n\n  // Process each field of the input object\n  for (const key in inputObject) {\n    if (inputObject.hasOwnProperty(key)) {\n      const value = inputObject[key];\n      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n        // Convert range object to array if min, max, and step are present\n        if ('min' in value && 'max' in value && 'step' in value) {\n          inputObject[key] = rangeToArray(value);\n        } else {\n          throw new Error(`Invalid range object for field '${key}'. Must contain min, max, and step properties.`);\n        }\n      }\n    }\n  }\n  return inputObject; // Return the processed input object\n};"],"names":[],"version":3,"file":"main.cjs.map","sourceRoot":"../../"}