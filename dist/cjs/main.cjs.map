{"mappings":"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","sources":["src/index.js","src/func/generatePermutations.js"],"sourcesContent":["export * from './func/generatePermutations.js';","const { DateTime } = require('luxon');\n\nexport const generatePermutations = (rawInputObject, options = {}) => {\n  const {inputObject, fieldTypes} = preprocessInput(JSON.parse(JSON.stringify(rawInputObject))); // Deep copy and preprocess\n\n\n  // Helper function to apply rules to current combination\n  function applyRules(rules, permutation) {\n    return rules.every((rule) => {\n      if (typeof rule.if === 'function') {\n        // Only apply 'then' conditions if 'if' condition returns true\n        if (rule.if(permutation)) {\n          // Check 'then' conditions for further restrictions\n          return checkThenConditions(rule.then, permutation);\n        } else {\n          // If 'if' condition returns false, this rule does not restrict the permutation\n          return true;\n        }\n      } else if (Array.isArray(rule.if)) {\n        const [field, operator, conditionValue] = rule.if;\n        // Apply 'then' conditions if the operator-based 'if' condition is met\n        return checkRule(field, operator, conditionValue, permutation, inputObject) ? checkThenConditions(rule.then, permutation) : true;\n      } else {\n        // Throw an error if the rule format is not recognized\n        throw new Error('Invalid rule format: \"if\" should be a function or an array.');\n      }\n    });\n  }\n\n  // Adjusted checkRule function to directly accept the parameters instead of the rule object\n  function checkRule(field, operator, conditionValue, permutation, inputObject) {\n    // console.log(field, operator, conditionValue, permutation, inputObject);\n    function checkCondition(operator, fieldValue, testValue) {\n      if (fieldTypes[field] === 'date') {\n        let fieldValue = DateTime.fromISO(permutation[field], { zone: 'utc' });\n        let testValue = DateTime.fromISO(conditionValue, { zone: 'utc' });\n        console.log(fieldValue, testValue);\n    \n        // Perform comparison based on Luxon's DateTime comparison methods\n        switch (operator) {\n          case '==':\n            return fieldValue.equals(testValue);\n          case '!=':\n            return !fieldValue.equals(testValue);\n          case '<':\n            return fieldValue < testValue;\n          case '<=':\n            return fieldValue <= testValue;\n          case '>':\n            return fieldValue > testValue;\n          case '>=':\n            return fieldValue >= testValue;\n          default:\n            throw new Error(`Invalid operator \"${operator}\" for date comparison.`);\n        }\n      } else {\n          \n        switch (operator) {\n          case '==':\n            return fieldValue == testValue;\n          case '!=':\n            return fieldValue != testValue;\n          case '<':\n            return fieldValue < testValue;\n          case '<=':\n            return fieldValue <= testValue;\n          case '>':\n            return fieldValue > testValue;\n          case '>=':\n            return fieldValue >= testValue;\n          default:\n            throw new Error(`Invalid operator \"${operator}\" used in rule definition.`);\n        }\n      }\n    }\n\n    let fieldValue = permutation[field];\n    if (Array.isArray(conditionValue)) {\n      // If conditionValue is an array, check if any value in the array meets the condition\n      return conditionValue.some((value) => checkCondition(operator, fieldValue, value));\n    } else {\n      // If conditionValue is not an array, directly check the condition\n      return checkCondition(operator, fieldValue, conditionValue);\n    }\n  }\n\n  // Helper function to check then conditions based on the current permutation\n  function checkThenConditions(thenConditions, permutation) {\n    return Object.entries(thenConditions).every(([field, values]) => {\n      values = Array.isArray(values) ? values : [values];\n      return values.includes(permutation[field]);\n    });\n  }\n\n  // Helper function to apply filters to permutations\n  function applyFilters(permutations, filters) {\n    return filters.reduce((filteredPermutations, filterFunc) => {\n      return filteredPermutations.filter(filterFunc);\n    }, permutations);\n  }\n\n  // Recursive function to generate all combinations\n  function permute(currentCombination = {}, remainingKeys = Object.keys(inputObject)) {\n    // If no remaining keys, apply rules and return the final combination\n    if (remainingKeys.length === 0) {\n      // First, apply rules to see if the current combination is valid\n      if (options.rules && !applyRules(options.rules, currentCombination)) {\n        return []; // If rules are not satisfied, filter out this combination\n      }\n      // If there are filters, apply them as well\n      return [currentCombination]; // Return combination as an array of one\n    }\n\n    let [key, ...nextKeys] = remainingKeys;\n    let results = [];\n\n    // Generate permutations for the remaining keys\n    const newOptions = nextKeys.length > 0 ? { ...inputObject, [key]: inputObject[key] } : inputObject;\n\n    for (let value of inputObject[key]) {\n      let newCombination = { ...currentCombination, [key]: value };\n      results = results.concat(permute(newCombination, nextKeys));\n    }\n\n    return results;\n  }\n\n  // Generate permutations and then apply any filters\n  let allPermutations = permute({}, Object.keys(inputObject));\n  if (options.filters) {\n    allPermutations = applyFilters(allPermutations, options.filters);\n  }\n\n  \n  // Validate input and options\n  if (typeof inputObject !== 'object' || inputObject == null) {\n    throw new TypeError('Input must be an object with array properties.');\n  }\n\n  for (let key in inputObject) {\n    if (!Array.isArray(inputObject[key])) {\n      throw new TypeError(`Value for ${key} must be an array.`);\n    }\n  }\n\n  // Generate and return permutations with rules applied\n  return allPermutations;\n}\n\n\nconst preprocessInput = (inputObject) => {\n\n  let fieldTypes = {};\n\n  // Function to convert range definition to an array\n  const rangeToArray = (range) => {\n    if (range.datetime) { // Check if the range is for datetime values\n      const { min, max, step, format } = range;\n      let arr = [];\n      let current = DateTime.fromISO(min, { zone: 'utc' });\n      const end = DateTime.fromISO(max, { zone: 'utc' });\n      const stepDuration = DateTime.fromObject(step); // Create a duration object for stepping\n\n      if (!current.isValid || !end.isValid) {\n        throw new Error('Invalid DateTime range: Ensure \"min\" and \"max\" are valid ISO8601 strings.');\n      }\n\n      while (current <= end) {\n        arr.push(format ? current.toFormat(format) : current.toISO());\n        current = current.plus(step); // Ensure the 'step' object is a valid duration for Luxon\n      }\n      return arr;\n    } else {\n      // Handle numeric range...\n      const { min, max, step } = range;\n      let arr = [];\n      for (let value = min; value <= max; value += step) {\n        arr.push(value);\n      }\n      return arr;\n    }\n\n  };\n\n  // Process each field of the input object\n  for (const key in inputObject) {\n    if (inputObject.hasOwnProperty(key)) {\n      const value = inputObject[key];\n      fieldTypes = { ...fieldTypes, [key]: 'string' };\n      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n        \n        if(value.datetime){\n          fieldTypes = { ...fieldTypes, [key]: 'date' };\n        } else {\n          fieldTypes = { ...fieldTypes, [key]: 'number' };\n        }\n\n        // Convert range object to array if min, max, and step are present\n        if ('min' in value && 'max' in value && 'step' in value) {\n          inputObject[key] = rangeToArray(value);\n        } else {\n          throw new Error(`Invalid range object for field '${key}'. Must contain min, max, and step properties.`);\n        }\n      }\n    }\n  }\n\n  // Add a tag to mark the field as a date field\n  for (const key in inputObject) {\n    if (inputObject.hasOwnProperty(key)) {\n      const field = inputObject[key];\n      if (field && typeof field === 'object' && !Array.isArray(field) && field.datetime) {\n        // Convert date range definitions to arrays and tag as date fields\n        \n      }\n    }\n  }\n\n  return {inputObject, fieldTypes}; // Return the processed input object\n};"],"names":[],"version":3,"file":"main.cjs.map","sourceRoot":"../../"}