{"mappings":"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","sources":["<anon>","src/index.js","src/func/generatePermutations.js"],"sourcesContent":["\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      }\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $d177698243aeee5c$exports = {};\n\n$parcel$export($d177698243aeee5c$exports, \"generatePermutations\", () => $d177698243aeee5c$export$c2e8d36f4b1181be);\nconst $d177698243aeee5c$export$c2e8d36f4b1181be = (rawInputObject, options = {})=>{\n    const inputObject = $d177698243aeee5c$var$preprocessInput(JSON.parse(JSON.stringify(rawInputObject))); // Deep copy and preprocess\n    // Helper function to check if the rule applies\n    function checkRule(rule, combination) {\n        // Check if a value matches the condition set in a rule\n        function checkCondition(field, operator, testValue, fieldValue) {\n            switch(operator){\n                case \"==\":\n                    return fieldValue == testValue;\n                case \"!=\":\n                    return fieldValue != testValue;\n                case \"<\":\n                    return fieldValue < testValue;\n                case \"<=\":\n                    return fieldValue <= testValue;\n                case \">\":\n                    return fieldValue > testValue;\n                case \">=\":\n                    return fieldValue >= testValue;\n                default:\n                    return false; // Invalid operator\n            }\n        }\n        // Execute the 'if' part of the rule\n        const [field, operator, conditionValue] = rule.if;\n        if (Array.isArray(conditionValue)) // If conditionValue is an array, check if any value in the array meets the condition\n        return conditionValue.some((value)=>checkCondition(field, operator, value, combination[field]));\n        else // If conditionValue is not an array, directly check the condition\n        return checkCondition(field, operator, conditionValue, combination[field]);\n    }\n    // Helper function to apply rules to current combination\n    function applyRules(rules, permutation) {\n        return rules.every((rule)=>{\n            if (checkRule(rule, permutation)) // If the rule applies, check that all 'then' conditions are satisfied\n            return Object.entries(rule.then).every(([thenField, thenValues])=>{\n                // If thenValues is not an array, convert it to an array for consistency\n                thenValues = Array.isArray(thenValues) ? thenValues : [\n                    thenValues\n                ];\n                // The current value for thenField in permutation must be one of the thenValues\n                return thenValues.includes(permutation[thenField]);\n            });\n            // If the rule doesn't apply, return true as this rule does not restrict this permutation\n            return true;\n        });\n    }\n    // Recursive function to generate all combinations\n    function permute(options, currentCombination = {}, remainingKeys = Object.keys(inputObject)) {\n        if (remainingKeys.length === 0) {\n            // Check if currentCombination respects the rules before adding it to results\n            if (!options.rules || applyRules(options.rules, currentCombination)) return [\n                currentCombination\n            ];\n            return []; // If rules don't apply, return an empty array to filter out this permutation.\n        }\n        let [key, ...nextKeys] = remainingKeys;\n        let results = [];\n        for (let value of inputObject[key]){\n            let newCombination = {\n                ...currentCombination,\n                [key]: value\n            };\n            results = results.concat(permute(options, newCombination, nextKeys));\n        }\n        return results;\n    }\n    // Validate input and options\n    if (typeof inputObject !== \"object\" || inputObject == null) throw new TypeError(\"Input must be an object with array properties.\");\n    for(let key in inputObject){\n        if (!Array.isArray(inputObject[key])) throw new TypeError(`Value for ${key} must be an array.`);\n    }\n    // Generate and return permutations with rules applied\n    return permute({\n        rules: options.rules\n    }, {});\n};\nconst $d177698243aeee5c$var$preprocessInput = (inputObject)=>{\n    // Function to convert range definition to an array\n    const rangeToArray = (range)=>{\n        const { min: min, max: max, step: step } = range;\n        let arr = [];\n        for(let value = min; value <= max; value += step)arr.push(value);\n        return arr;\n    };\n    // Process each field of the input object\n    for(const key in inputObject)if (inputObject.hasOwnProperty(key)) {\n        const value = inputObject[key];\n        if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n            // Convert range object to array if min, max, and step are present\n            if (\"min\" in value && \"max\" in value && \"step\" in value) inputObject[key] = rangeToArray(value);\n            else throw new Error(`Invalid range object for field '${key}'. Must contain min, max, and step properties.`);\n        }\n    }\n    return inputObject; // Return the processed input object\n};\n\n\n$parcel$exportWildcard(module.exports, $d177698243aeee5c$exports);\n\n\n//# sourceMappingURL=main.cjs.map\n","export * from './func/generatePermutations.js';","export const generatePermutations = (rawInputObject, options = {}) => {\n  const inputObject = preprocessInput(JSON.parse(JSON.stringify(rawInputObject))); // Deep copy and preprocess\n\n\n    // Helper function to check if the rule applies\n  function checkRule(rule, combination) {\n    // Check if a value matches the condition set in a rule\n    function checkCondition(field, operator, testValue, fieldValue) {\n      switch (operator) {\n        case '==':\n          return fieldValue == testValue;\n        case '!=':\n          return fieldValue != testValue;\n        case '<':\n          return fieldValue < testValue;\n        case '<=':\n          return fieldValue <= testValue;\n        case '>':\n          return fieldValue > testValue;\n        case '>=':\n          return fieldValue >= testValue;\n        default:\n          return false; // Invalid operator\n      }\n    }\n\n    // Execute the 'if' part of the rule\n    const [field, operator, conditionValue] = rule.if;\n    if (Array.isArray(conditionValue)) {\n      // If conditionValue is an array, check if any value in the array meets the condition\n      return conditionValue.some((value) => checkCondition(field, operator, value, combination[field]));\n    } else {\n      // If conditionValue is not an array, directly check the condition\n      return checkCondition(field, operator, conditionValue, combination[field]);\n    }\n  }\n\n  // Helper function to apply rules to current combination\n  function applyRules(rules, permutation) {\n    return rules.every((rule) => {\n      if (checkRule(rule, permutation)) {\n        // If the rule applies, check that all 'then' conditions are satisfied\n        return Object.entries(rule.then).every(([thenField, thenValues]) => {\n          // If thenValues is not an array, convert it to an array for consistency\n          thenValues = Array.isArray(thenValues) ? thenValues : [thenValues];\n          // The current value for thenField in permutation must be one of the thenValues\n          return thenValues.includes(permutation[thenField]);\n        });\n      }\n      // If the rule doesn't apply, return true as this rule does not restrict this permutation\n      return true;\n    });\n  }\n\n  // Recursive function to generate all combinations\n  function permute(options, currentCombination = {}, remainingKeys = Object.keys(inputObject)) {\n    if (remainingKeys.length === 0) {\n      // Check if currentCombination respects the rules before adding it to results\n      if (!options.rules || applyRules(options.rules, currentCombination)) {\n        return [currentCombination];\n      }\n      return []; // If rules don't apply, return an empty array to filter out this permutation.\n    }\n  \n    let [key, ...nextKeys] = remainingKeys;\n    let results = [];\n  \n    for (let value of inputObject[key]) {\n      let newCombination = { ...currentCombination, [key]: value };\n      results = results.concat(permute(options, newCombination, nextKeys));\n    }\n  \n    return results;\n  }\n\n  // Validate input and options\n  if (typeof inputObject !== 'object' || inputObject == null) {\n    throw new TypeError('Input must be an object with array properties.');\n  }\n\n  for (let key in inputObject) {\n    if (!Array.isArray(inputObject[key])) {\n      throw new TypeError(`Value for ${key} must be an array.`);\n    }\n  }\n\n  // Generate and return permutations with rules applied\n  return permute({ rules: options.rules }, {});\n}\n\n\nconst preprocessInput = (inputObject) => {\n  // Function to convert range definition to an array\n  const rangeToArray = (range) => {\n    const { min, max, step } = range;\n    let arr = [];\n    for (let value = min; value <= max; value += step) {\n      arr.push(value);\n    }\n    return arr;\n  };\n\n  // Process each field of the input object\n  for (const key in inputObject) {\n    if (inputObject.hasOwnProperty(key)) {\n      const value = inputObject[key];\n      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n        // Convert range object to array if min, max, and step are present\n        if ('min' in value && 'max' in value && 'step' in value) {\n          inputObject[key] = rangeToArray(value);\n        } else {\n          throw new Error(`Invalid range object for field '${key}'. Must contain min, max, and step properties.`);\n        }\n      }\n    }\n  }\n  return inputObject; // Return the processed input object\n};"],"names":["dest","$d177698243aeee5c$exports","Object","defineProperty","get","$d177698243aeee5c$export$c2e8d36f4b1181be","set","s","enumerable","configurable","rawInputObject","options","inputObject","$d177698243aeee5c$var$preprocessInput","JSON","parse","stringify","TypeError","key","Array","isArray","permute","currentCombination","remainingKeys","keys","length","rules","every","rule","checkRule","combination","checkCondition","field","operator","testValue","fieldValue","conditionValue","if","some","value","entries","then","thenField","thenValues","includes","permutation","nextKeys","results","newCombination","concat","rangeToArray","range","min","max","step","arr","push","hasOwnProperty","Error","module","exports","forEach","source"],"version":3,"file":"main.cjs.map"}