{"mappings":"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","sources":["src/index.js","src/func/generatePermutations.js"],"sourcesContent":["export * from './func/generatePermutations.js';","export const generatePermutations = (rawInputObject, options = {}) => {\n  const inputObject = preprocessInput(JSON.parse(JSON.stringify(rawInputObject))); // Deep copy and preprocess\n\n\n    // Helper function to check if the rule applies\n  function checkRule(rule, combination) {\n    // Check if a value matches the condition set in a rule\n    function checkCondition(field, operator, testValue, fieldValue) {\n      switch (operator) {\n        case '==':\n          return fieldValue == testValue;\n        case '!=':\n          return fieldValue != testValue;\n        case '<':\n          return fieldValue < testValue;\n        case '<=':\n          return fieldValue <= testValue;\n        case '>':\n          return fieldValue > testValue;\n        case '>=':\n          return fieldValue >= testValue;\n        default:\n          return false; // Invalid operator\n      }\n    }\n\n    // Execute the 'if' part of the rule\n    const [field, operator, conditionValue] = rule.if;\n    if (Array.isArray(conditionValue)) {\n      // If conditionValue is an array, check if any value in the array meets the condition\n      return conditionValue.some((value) => checkCondition(field, operator, value, combination[field]));\n    } else {\n      // If conditionValue is not an array, directly check the condition\n      return checkCondition(field, operator, conditionValue, combination[field]);\n    }\n  }\n\n  // Helper function to apply rules to current combination\n  function applyRules(rules, permutation) {\n    return rules.every((rule) => {\n      if (checkRule(rule, permutation)) {\n        // If the rule applies, check that all 'then' conditions are satisfied\n        return Object.entries(rule.then).every(([thenField, thenValues]) => {\n          // If thenValues is not an array, convert it to an array for consistency\n          thenValues = Array.isArray(thenValues) ? thenValues : [thenValues];\n          // The current value for thenField in permutation must be one of the thenValues\n          return thenValues.includes(permutation[thenField]);\n        });\n      }\n      // If the rule doesn't apply, return true as this rule does not restrict this permutation\n      return true;\n    });\n  }\n\n  // Recursive function to generate all combinations\n  function permute(options, currentCombination = {}, remainingKeys = Object.keys(inputObject)) {\n    if (remainingKeys.length === 0) {\n      // Check if currentCombination respects the rules before adding it to results\n      if (!options.rules || applyRules(options.rules, currentCombination)) {\n        return [currentCombination];\n      }\n      return []; // If rules don't apply, return an empty array to filter out this permutation.\n    }\n  \n    let [key, ...nextKeys] = remainingKeys;\n    let results = [];\n  \n    for (let value of inputObject[key]) {\n      let newCombination = { ...currentCombination, [key]: value };\n      results = results.concat(permute(options, newCombination, nextKeys));\n    }\n  \n    return results;\n  }\n\n  // Validate input and options\n  if (typeof inputObject !== 'object' || inputObject == null) {\n    throw new TypeError('Input must be an object with array properties.');\n  }\n\n  for (let key in inputObject) {\n    if (!Array.isArray(inputObject[key])) {\n      throw new TypeError(`Value for ${key} must be an array.`);\n    }\n  }\n\n  // Generate and return permutations with rules applied\n  return permute({ rules: options.rules }, {});\n}\n\n\nconst preprocessInput = (inputObject) => {\n  // Function to convert range definition to an array\n  const rangeToArray = (range) => {\n    const { min, max, step } = range;\n    let arr = [];\n    for (let value = min; value <= max; value += step) {\n      arr.push(value);\n    }\n    return arr;\n  };\n\n  // Process each field of the input object\n  for (const key in inputObject) {\n    if (inputObject.hasOwnProperty(key)) {\n      const value = inputObject[key];\n      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n        // Convert range object to array if min, max, and step are present\n        if ('min' in value && 'max' in value && 'step' in value) {\n          inputObject[key] = rangeToArray(value);\n        } else {\n          throw new Error(`Invalid range object for field '${key}'. Must contain min, max, and step properties.`);\n        }\n      }\n    }\n  }\n  return inputObject; // Return the processed input object\n};"],"names":[],"version":3,"file":"main.js.map"}